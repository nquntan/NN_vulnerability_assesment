import os
import numpy as np
import argparse
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim

import random
from art.utils import projection
from art.utils import random_sphere
from art.utils import load_dataset
from art.classifiers import PyTorchClassifier
from model.vgg import *
from utils import *


# os.environ["CUDA_VISIBLE_DEVICES"]="2"

norm_list = {
    "l1" : 1,
    "l2" : 2,
    "inf" : np.inf,
}

def main(args):
    mode = args.mode
    eps = args.eps
    norm = norm_list.get(args.norm)
    p_mod = args.p_mod

    (x_train, y_train), (x_test, y_test), min_, max_ = load_dataset(str('cifar10'))
    x_train = np.swapaxes(x_train, 1, 3).astype(np.float32)
    x_test = np.swapaxes(x_test, 1, 3).astype(np.float32)

    x_train = x_train[:500]
    y_train = y_train[:500]

    model = VGG('VGG16')

    model.load_state_dict(torch.load("./logs/pytorch_vgg16.model"))
    criterion = nn.CrossEntropyLoss()
    optimizer = optim.Adam(model.parameters(), lr=1e-2)

    classifier = PyTorchClassifier(model=model, clip_values=(min_, max_ ), loss=criterion,
                                optimizer=optimizer, input_shape=(3, 32, 32), nb_classes=10)

    predictions = classifier.predict(x_test)
    accuracy = np.sum(np.argmax(predictions, axis=1) == np.argmax(y_test, axis=1)) / len(y_test)
    print('Accuracy on benign test examples: {}%'.format(accuracy * 100))

    x = x_train.copy().astype(np.float32)

    nb_instances = len(x)
    pred_y = classifier.predict(x)

    nb_dims = x.shape[1] * x.shape[2] * x.shape[3]
    # 変更を加えるピクセル数
    n_mod = int(round(nb_dims * p_mod))

    v = random_sphere(nb_points=1, nb_dims=nb_dims, radius=eps, norm=norm)
    v = v.reshape(1, x.shape[1], x.shape[2], x.shape[3])
    v = np.array(v, dtype = 'float32')
    v_max = v.copy()
    current_y = classifier.predict(x + v)
    fooling_rate = loss_fn(pred_y, current_y, mode = mode)
    fooling_rate_max = fooling_rate
    # 初期温度
    temperature = 100

    # Go through the data set and compute the perturbation increments sequentially
    for j in range(len(x)):
        v_ = v.reshape(nb_dims).copy()
        # 変更を加えるピクセルの番地
        idx = random.sample(range(len(v_)), n_mod)
        # 正規分布からの乱数で置き換え
        #v_[idx] = np.random.normal(loc=0.0, scale=np.std(v_), size=n_mod)
        # 正規分布からの乱数を加算
        v_[idx] = v_[idx] + np.random.normal(loc=0.0, scale=np.std(v_), size=n_mod)
        # 均一分布からの乱数を加算
        #v_[idx] = v_[idx] + np.random.uniform(low=v_.min(), high=v_.max(), size=n_mod)
        # 均一分布から乱数で置き換え
        #v_[idx] = np.random.uniform(low=v_.min(), high=v_.max(), size=n_mod)
        
        # 摂動が任意の長さに収まるように射影
        v_ = projection(v_.reshape(1, 3, 32, 32), eps, norm)
        # fooling rate
        current_y= classifier.predict(x + v_)
        fooling_rate_ = loss_fn(pred_y, current_y, mode = mode)
        # 判定
        if random.random() < np.exp((fooling_rate_ - fooling_rate_max) / temperature):
            print(j, fooling_rate_, fooling_rate_max, temperature, np.linalg.norm(v_))
            v = v_.copy()
            if fooling_rate_max < fooling_rate_:
                fooling_rate_max = fooling_rate_
                v_max = v_.copy()
            fooling_rate = fooling_rate_
        temperature = 0.99 * temperature

    # Compute fooling rate
    adv_x = x + v_max
    adv_y = classifier.predict(adv_x)
    fooling_rate = loss_fn(pred_y, adv_y, mode = "fool_rate")
    print(fooling_rate)



if __name__ == "__main__":  
    parser = argparse.ArgumentParser(description='PyTorch Template')
    parser.add_argument('-m', '--mode', default="fool_rate", type=str,
                      help='list of loss_fn')
    parser.add_argument('-n', '--norm', default=2, type=str,
                      help = "list of norm { l1 : l1 norm, l2 : l2 norm, inf : infinity norm}")
    parser.add_argument('-e', '--eps', default=0.1, type=float,
                      help = "eps")
    parser.add_argument('-p', '--p_mod', default=0.1, type=float,
                      help = "percent of area")
    parser.add_argument('-d', '--device', default="2", type=str,
                      help='indices of GPUs to enable (default: all)')
    args = parser.parse_args()
    os.environ["CUDA_VISIBLE_DEVICES"]=args.device
    main(args)



